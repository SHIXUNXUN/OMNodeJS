"use strict";
/*
 *  corba.js Object Request Broker (ORB) and Interface Definition Language (IDL) compiler
 *  Copyright (C) 2018, 2020 Mark-Andr√© Hopf <mhopf@mark13.org>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = void 0;
const idl_node_1 = require("./idl-node");
class Lexer {
    constructor(data) {
        this.data = data;
        this.line = 1;
        this.column = 1;
        this.pos = 0;
        this.state = 0;
        this.tokenStack = new Array();
    }
    static isAlpha(c) {
        let n = c.charCodeAt(0);
        return ((0x41 <= n && n <= 0x5a) ||
            (0x61 <= n && n <= 0x7a));
    }
    static isDigit(c) {
        let n = c.charCodeAt(0);
        return (0x30 <= n && n <= 0x39);
    }
    static isAlphaNumeric(c) {
        return Lexer.isAlpha(c) || Lexer.isDigit(c);
    }
    eof() {
        return this.pos >= this.data.length;
    }
    getc() {
        let c = this.data[this.pos++];
        if (c == '\n') {
            ++this.line;
            this.column = 1;
        }
        else {
            ++this.column; // FIXME: tabulators
        }
        return c;
    }
    ungetc() {
        let c = this.data[--this.pos];
        if (c == '\n') {
            let i;
            for (i = this.pos; i > 0; --i) {
                if (this.data[i] == '\n')
                    break;
            }
            this.column = i;
            --this.line;
        }
        else {
            --this.column;
        }
    }
    unlex(token) {
        if (token === undefined)
            return;
        if (token.child.length !== 0)
            throw Error("can not unlex token " + token.toString() + " with children");
        // FIXME: adjust this.line and this.column
        this.tokenStack.push(token);
    }
    lex() {
        if (this.tokenStack.length > 0) {
            return this.tokenStack.pop();
        }
        while (!this.eof()) {
            let c = this.getc();
            //console.log("state="+this.state+" c='"+c+"'")
            let oldstate = this.state;
            switch (this.state) {
                case 0:
                    switch (c) {
                        case ' ':
                        case '\r':
                        case '\n':
                        case '\t':
                        case '\v':
                            break;
                        case '/':
                            this.state = 3;
                            break;
                        case '_':
                            this.state = 1;
                            this.text = "";
                            continue;
                        case ':':
                            this.state = 7;
                            break;
                        default:
                            if (Lexer.isAlpha(c)) {
                                this.state = 2;
                            }
                            else {
                                return new idl_node_1.Node(idl_node_1.Type.TKN_TEXT, c);
                            }
                            break;
                    }
                    break;
                case 1: // _<identifier> CORBA IDL style identifier escape
                    if (!Lexer.isAlpha(c)) {
                        this.ungetc();
                        this.state = 0;
                        return new idl_node_1.Node(idl_node_1.Type.TKN_IDENTIFIER, this.text);
                    }
                    break;
                case 2: // <identifier>
                    if (!Lexer.isAlphaNumeric(c) && c !== "_") {
                        this.ungetc();
                        this.state = 0;
                        switch (this.text) {
                            case "abstract": return new idl_node_1.Node(idl_node_1.Type.TKN_ABSTRACT);
                            case "any": return new idl_node_1.Node(idl_node_1.Type.TKN_ANY);
                            case "attribute": return new idl_node_1.Node(idl_node_1.Type.TKN_ATTRIBUTE);
                            case "boolean": return new idl_node_1.Node(idl_node_1.Type.TKN_BOOLEAN);
                            case "case": return new idl_node_1.Node(idl_node_1.Type.TKN_CASE);
                            case "char": return new idl_node_1.Node(idl_node_1.Type.TKN_CHAR);
                            case "component": return new idl_node_1.Node(idl_node_1.Type.TKN_COMPONENT);
                            case "const": return new idl_node_1.Node(idl_node_1.Type.TKN_CONST);
                            case "consumes": return new idl_node_1.Node(idl_node_1.Type.TKN_CONSUMES);
                            case "context": return new idl_node_1.Node(idl_node_1.Type.TKN_CONTEXT);
                            case "custom": return new idl_node_1.Node(idl_node_1.Type.TKN_CUSTOM);
                            case "default": return new idl_node_1.Node(idl_node_1.Type.TKN_DEFAULT);
                            case "double": return new idl_node_1.Node(idl_node_1.Type.TKN_DOUBLE);
                            case "exception": return new idl_node_1.Node(idl_node_1.Type.TKN_EXCEPTION);
                            case "emits": return new idl_node_1.Node(idl_node_1.Type.TKN_EMITS);
                            case "enum": return new idl_node_1.Node(idl_node_1.Type.TKN_ENUM);
                            case "eventtype": return new idl_node_1.Node(idl_node_1.Type.TKN_EVENTTYPE);
                            case "factory": return new idl_node_1.Node(idl_node_1.Type.TKN_FACTORY);
                            case "FALSE": return new idl_node_1.Node(idl_node_1.Type.TKN_FALSE);
                            case "finder": return new idl_node_1.Node(idl_node_1.Type.TKN_FINDER);
                            case "fixed": return new idl_node_1.Node(idl_node_1.Type.TKN_FIXED);
                            case "float": return new idl_node_1.Node(idl_node_1.Type.TKN_FLOAT);
                            case "getraises": return new idl_node_1.Node(idl_node_1.Type.TKN_GETRAISES);
                            case "home": return new idl_node_1.Node(idl_node_1.Type.TKN_HOME);
                            case "import": return new idl_node_1.Node(idl_node_1.Type.TKN_IMPORT);
                            case "in": return new idl_node_1.Node(idl_node_1.Type.TKN_IN);
                            case "inout": return new idl_node_1.Node(idl_node_1.Type.TKN_INOUT);
                            case "interface": return new idl_node_1.Node(idl_node_1.Type.TKN_INTERFACE);
                            case "local": return new idl_node_1.Node(idl_node_1.Type.TKN_LOCAL);
                            case "long": return new idl_node_1.Node(idl_node_1.Type.TKN_LONG);
                            case "module": return new idl_node_1.Node(idl_node_1.Type.TKN_MODULE);
                            case "multiple": return new idl_node_1.Node(idl_node_1.Type.TKN_MULTIPLE);
                            case "native": return new idl_node_1.Node(idl_node_1.Type.TKN_NATIVE);
                            case "Object": return new idl_node_1.Node(idl_node_1.Type.TKN_OBJECT);
                            case "octet": return new idl_node_1.Node(idl_node_1.Type.TKN_OCTET);
                            case "oneway": return new idl_node_1.Node(idl_node_1.Type.TKN_ONEWAY);
                            case "out": return new idl_node_1.Node(idl_node_1.Type.TKN_OUT);
                            case "primarykey": return new idl_node_1.Node(idl_node_1.Type.TKN_PRIMARYKEY);
                            case "private": return new idl_node_1.Node(idl_node_1.Type.TKN_PRIVATE);
                            case "provides": return new idl_node_1.Node(idl_node_1.Type.TKN_PROVIDES);
                            case "public": return new idl_node_1.Node(idl_node_1.Type.TKN_PUBLIC);
                            case "publishes": return new idl_node_1.Node(idl_node_1.Type.TKN_PUBLISHES);
                            case "raises": return new idl_node_1.Node(idl_node_1.Type.TKN_RAISES);
                            case "readonly": return new idl_node_1.Node(idl_node_1.Type.TKN_READONLY);
                            case "setraises": return new idl_node_1.Node(idl_node_1.Type.TKN_SETRAISES);
                            case "sequence": return new idl_node_1.Node(idl_node_1.Type.TKN_SEQUENCE);
                            case "short": return new idl_node_1.Node(idl_node_1.Type.TKN_SHORT);
                            case "string": return new idl_node_1.Node(idl_node_1.Type.TKN_STRING);
                            case "struct": return new idl_node_1.Node(idl_node_1.Type.TKN_STRUCT);
                            case "supports": return new idl_node_1.Node(idl_node_1.Type.TKN_SUPPORTS);
                            case "switch": return new idl_node_1.Node(idl_node_1.Type.TKN_SWITCH);
                            case "TRUE": return new idl_node_1.Node(idl_node_1.Type.TKN_TRUE);
                            case "truncatable": return new idl_node_1.Node(idl_node_1.Type.TKN_TRUNCATABLE);
                            case "typedef": return new idl_node_1.Node(idl_node_1.Type.TKN_TYPEDEF);
                            case "typeid": return new idl_node_1.Node(idl_node_1.Type.TKN_TYPEID);
                            case "typeprefix": return new idl_node_1.Node(idl_node_1.Type.TKN_TYPEPREFIX);
                            case "unsigned": return new idl_node_1.Node(idl_node_1.Type.TKN_UNSIGNED);
                            case "union": return new idl_node_1.Node(idl_node_1.Type.TKN_UNION);
                            case "uses": return new idl_node_1.Node(idl_node_1.Type.TKN_USES);
                            case "ValueBase": return new idl_node_1.Node(idl_node_1.Type.TKN_VALUEBASE);
                            case "valuetype": return new idl_node_1.Node(idl_node_1.Type.TKN_VALUETYPE);
                            case "void": return new idl_node_1.Node(idl_node_1.Type.TKN_VOID);
                            case "wchar": return new idl_node_1.Node(idl_node_1.Type.TKN_WCHAR);
                            case "wstring": return new idl_node_1.Node(idl_node_1.Type.TKN_WSTRING);
                            default:
                                return new idl_node_1.Node(idl_node_1.Type.TKN_IDENTIFIER, this.text);
                        }
                    }
                    break;
                case 3: // /...
                    switch (c) {
                        case '/':
                            this.state = 4;
                            break;
                        case '*':
                            this.state = 5;
                            break;
                        default:
                            this.ungetc();
                            return new idl_node_1.Node(idl_node_1.Type.TKN_TEXT, '/');
                    }
                    break;
                case 4: // //...
                    switch (c) {
                        case '\n':
                            this.state = 0;
                            break;
                    }
                    break;
                case 5: // /*...
                    switch (c) {
                        case '*':
                            this.state = 6;
                            break;
                    }
                    break;
                case 6: // /*...*
                    switch (c) {
                        case '/':
                            this.state = 0;
                            break;
                        case '*':
                            break;
                        default:
                            this.state = 5;
                    }
                    break;
                case 7: // :
                    this.state = 0;
                    if (c == ':') {
                        return new idl_node_1.Node(idl_node_1.Type.TKN_COLON_COLON, "::");
                    }
                    else {
                        this.ungetc();
                        return new idl_node_1.Node(idl_node_1.Type.TKN_TEXT, ':');
                    }
            }
            if (oldstate == 0) {
                this.text = c;
            }
            else {
                this.text += c;
            }
        }
        return undefined;
    }
}
exports.Lexer = Lexer;
//# sourceMappingURL=idl-lexer.js.map