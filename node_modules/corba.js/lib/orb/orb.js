"use strict";
/*
 *  corba.js Object Request Broker (ORB) and Interface Definition Language (IDL) compiler
 *  Copyright (C) 2018 Mark-Andr√© Hopf <mhopf@mark13.org>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stub = exports.Skeleton = exports.CORBAObject = exports.ORB = void 0;
class ORB {
    constructor(orb) {
        if (orb === undefined) {
            this.debug = 0;
            this.servants = new Array();
            this.servants.push(undefined); // reserve id 0
            this.unusedServantIds = new Array();
            this.stubsByName = new Map();
            this.initialReferences = new Map();
            this.name = "";
        }
        else {
            this.debug = orb.debug;
            this.servants = orb.servants;
            this.unusedServantIds = orb.unusedServantIds;
            this.stubsByName = orb.stubsByName;
            this.initialReferences = orb.initialReferences;
            this.name = "spawned from '" + orb.name + "'";
        }
        this.stubsById = new Map();
        this.accesibleServants = new Set();
        this.reqid = 0;
        this.listeners = new Map();
    }
    // EventTarget methods
    addEventListener(type, listener, options) {
        if (type !== "close")
            throw Error("ORB.addEventListener: type must be 'close'");
        if (listener === null)
            return;
        let set = this.listeners.get(type);
        if (set === undefined) {
            set = new Set();
            this.listeners.set(type, set);
        }
        set.add(listener);
    }
    removeEventListener(type, listener, options) {
        if (type !== "close")
            throw Error("ORB.removeEventListener: type must be 'close'");
        if (listener === null || listener === undefined)
            return;
        let set = this.listeners.get(type);
        if (set === undefined)
            return;
        set.delete(listener);
    }
    dispatchEvent(event) {
        let set = this.listeners.get(event.type);
        if (set === undefined)
            return true;
        for (let handler of set) {
            if (typeof handler === "function")
                handler(event);
            else
                handler.handleEvent(event);
        }
        return true;
    }
    set onclose(listener) {
        this.listeners.delete("close");
        this.addEventListener("close", listener);
    }
    // called by the Skeleton
    registerServant(servant) {
        let id = this.unusedServantIds.pop();
        if (id !== undefined) {
            this.servants[id] = servant;
        }
        else {
            id = this.servants.length;
            this.servants.push(servant);
        }
        return id;
    }
    unregisterServant(servant) {
        this.servants[servant.id] = undefined;
        this.unusedServantIds.push(servant.id);
        servant.id = -1;
    }
    registerStubClass(aStubClass) {
        this.stubsByName.set(aStubClass._idlClassName(), aStubClass);
    }
    releaseStub(stub) {
        if (!this.stubsById.has(stub.id))
            throw Error("ORB.releaseStub(): the stub with id " + stub.id + " is unknown to this ORB");
        this.stubsById.delete(stub.id);
    }
    static registerValueType(name, valuetypeConstructor) {
        let information = ORB.valueTypeByName.get(name);
        if (information === undefined) {
            throw Error(`ORB.registerValueType: valuetype '${name}' not defined in IDL`);
        }
        if (information.construct !== undefined) {
            throw Error(`ORB.registerValueType: valuetype '${name}' is already registered`);
        }
        information.name = name;
        information.construct = valuetypeConstructor;
        ORB.valueTypeByPrototype.set(valuetypeConstructor.prototype, information);
    }
    static lookupValueType(name) {
        let information = ORB.valueTypeByName.get(name);
        if (information === undefined) {
            throw Error(`ORB.lookupValueType: valuetype '${name}' not defined in IDL`);
        }
        if (information.construct === undefined) {
            throw Error(`ORB.lookupValueType: valuetype '${name}' not registered via ORB.registerValueType()`);
        }
        return information.construct;
    }
    //
    // initial references
    //
    bind(id, obj) {
        if (this.initialReferences.get(id) !== undefined)
            throw Error("ORB.bind(): the id '" + id + "' is already bound to an object");
        this.initialReferences.set(id, obj);
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            let result = new Array();
            for (let [id, obj] of this.initialReferences) {
                result.push(id);
            }
            if (this.socket === undefined)
                return result;
            let data = {
                "corba": "1.0",
                "list": null
            };
            let remoteInitialReferences = yield this.send(data);
            for (let id of remoteInitialReferences.result) {
                result.push(id);
            }
            return result;
        });
    }
    resolve(id) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = {
                "corba": "1.0",
                "resolve": id
            };
            let remoteInitialReference = yield this.send(data);
            if (remoteInitialReference.result === undefined) {
                throw Error("ORB.resolve('" + id + "'): protocol error, no result value");
            }
            let object = this.deserialize(remoteInitialReference.result);
            if (object === null) {
                throw Error("ORB.resolve('" + id + "'): failed to resolve reference");
            }
            return object;
        });
    }
    //
    // valuetype
    //
    serialize(object) {
        if (object === null || typeof object !== "object") {
            return JSON.stringify(object);
        }
        if (object instanceof Stub) {
            throw Error("ORB.serialize(): Stub");
        }
        if (object instanceof Skeleton) {
            return `{"#R":"${object.constructor._idlClassName()}","#V":${object.id}}`;
        }
        if (object instanceof Array) {
            let data = "";
            for (let x of object) {
                if (data.length !== 0)
                    data += ",";
                data += this.serialize(x);
            }
            return "[" + data + "]";
        }
        let data = "";
        let prototype = Object.getPrototypeOf(object);
        let valueTypeInformation;
        while (prototype !== null) {
            valueTypeInformation = ORB.valueTypeByPrototype.get(prototype);
            if (valueTypeInformation !== undefined)
                break;
            prototype = Object.getPrototypeOf(prototype);
        }
        if (valueTypeInformation === undefined) {
            console.log(object);
            throw Error("ORB: can not serialize object of unregistered valuetype");
        }
        for (let attribute of valueTypeInformation.attributes) {
            if (object[attribute] !== undefined) {
                if (data.length !== 0)
                    data += ",";
                data += '"' + attribute + '":' + this.serialize(object[attribute]);
            }
        }
        return `{"#T":"${valueTypeInformation.name}","#V":{${data}}}`;
    }
    deserialize(text) {
        if (text === undefined || text === null)
            return null;
        try {
            return this._deserialize(JSON.parse(text));
        }
        catch (error) {
            console.log(text);
            throw error;
        }
    }
    _deserialize(data) {
        if (data === null)
            return null;
        if (typeof data !== "object")
            return data;
        if (data instanceof Array) {
            for (let i in data) {
                data[i] = this._deserialize(data[i]);
            }
            return data;
        }
        let type = data["#T"];
        let reference = data["#R"];
        let value = data["#V"];
        if (reference !== undefined && value !== undefined) {
            let object = this.stubsById.get(value);
            if (object !== undefined)
                return object;
            let aStubClass = this.stubsByName.get(reference);
            if (aStubClass === undefined) {
                throw Error(`ORB: can not deserialize object of unregistered stub '${reference}'`);
            }
            object = new aStubClass(this, value);
            this.stubsById.set(value, object);
            return object;
        }
        if (type === undefined || value === undefined) {
            throw Error("ORB: no type/value information in serialized data");
        }
        let valueTypeInformation = ORB.valueTypeByName.get(type);
        if (valueTypeInformation === undefined)
            throw Error(`ORB: can not deserialize object of unregistered valuetype '${type}'`);
        let object = new valueTypeInformation.construct();
        for (let [innerAttribute, innerValue] of Object.entries(value)) {
            object[innerAttribute] = this._deserialize(innerValue);
        }
        return object;
    }
    //
    // Client
    //
    connect(url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug > 0)
                console.log("ORB.connect('" + url + ")");
            let orb = this;
            return new Promise((resolve, reject) => {
                orb.socket = new WebSocket(url);
                orb.socket.onopen = function () {
                    resolve();
                };
                orb.socket.onerror = function (err) {
                    reject(err);
                };
                orb.socket.onclose = (event) => {
                    this.dispatchEvent(event);
                    this.release();
                };
            });
        });
    }
    send(data, oneway = false) {
        let reqid = ++this.reqid;
        data.reqid = reqid;
        if (this.debug > 0) {
            console.log("ORB.send(" + JSON.stringify(data) + ")");
        }
        return new Promise((resolve, reject) => {
            if (this.socket === undefined)
                throw Error("ORB.send(): no socket");
            this.socket.onmessage = (message) => {
                if (this.debug > 0) {
                    console.log("ORB.send(...) received " + message.data);
                }
                let msg = JSON.parse(String(message.data));
                if (msg.corba !== "1.0")
                    reject(Error("expected corba version 1.0 but got " + msg.corba));
                if (msg.method !== undefined) {
                    try {
                        this.handleMethod(msg);
                    }
                    catch (error) {
                        if (error instanceof Error)
                            console.log(error.message);
                        else
                            console.log(error);
                        throw error;
                    }
                }
                else if (msg.list !== undefined) {
                    this.handleListInitialReferences(msg);
                }
                else if (msg.resolve !== undefined) {
                    this.handleResolveInitialReferences(msg);
                }
                else if (reqid == msg.reqid) {
                    resolve(msg);
                }
            };
            this.socket.onerror = function (err) {
                reject(err);
            };
            this.socket.send(JSON.stringify(data));
            if (oneway) {
                resolve(undefined);
            }
        });
    }
    call(stub, oneway, method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            // throw Error("FAILURE")
            if (this.debug > 0) {
                console.log("ORB.call(...) method " + method);
            }
            for (let i in params) {
                if (params[i] instanceof Skeleton) {
                    this.aclAdd(params[i]);
                }
                if (params[i] instanceof Stub) {
                    throw Error("ORB.call(): not implemented: method '" + method + "' received stub as argument");
                }
                try {
                    params[i] = this.serialize(params[i]);
                }
                catch (error) {
                    console.log(error);
                    throw error;
                }
            }
            let msg = yield this.send({
                "corba": "1.0",
                "method": method,
                "params": params,
                "id": stub.id
            }, oneway);
            if (!oneway)
                return this.deserialize(msg.result);
        });
    }
    release() {
        this.aclDeleteAll();
    }
    aclAdd(servant) {
        servant.acl.add(this);
        this.accesibleServants.add(servant);
    }
    aclDeleteAll() {
        for (let servant of this.accesibleServants)
            servant.acl.delete(this);
        this.accesibleServants.clear();
    }
    handleMethod(msg) {
        if (this.debug > 0)
            console.log("ORB.handleMethod(", msg, ")");
        if (msg.id >= this.servants.length) {
            throw Error("ORB.handleMethod(): client required method '" + msg.method + "' on server for unknown servant id " + msg.id);
        }
        let servant = this.servants[msg.id];
        if (servant === undefined) {
            throw Error("ORB.handleMethod(): client required method '" + msg.method + "' on server for unknown servant id " + msg.id);
        }
        if (!servant.acl.has(this)) {
            throw Error("ORB.handleMethod(): client required method '" + msg.method + "' on server but has no rights to access servant with id " + msg.id);
        }
        if (servant[msg.method] === undefined) {
            throw Error("ORB.handleMethod(): client required unknown method '" + msg.method + "' on server for servant with id " + msg.id);
        }
        for (let i in msg.params) {
            msg.params[i] = this.deserialize(msg.params[i]);
        }
        servant.orb = this; // set orb to client connection orb
        let result = servant[msg.method].apply(servant, msg.params);
        if (this.debug > 0)
            console.log("ORB.handleMethod(): got result ", result);
        result
            .then((result) => {
            if (result === undefined)
                return;
            if (result instanceof Skeleton) {
                this.aclAdd(result);
                result.orb = this; // replace listener orb with client connection orb
            }
            if (result instanceof Stub) {
                throw Error("ORB.handleMethod(): method '" + msg.method + "' returned stub");
            }
            let answer = {
                "corba": "1.0",
                "result": this.serialize(result),
                "reqid": msg.reqid
            };
            let text = JSON.stringify(answer);
            if (this.debug > 0) {
                console.log("ORB.handleMethod(): sending call reply " + text);
            }
            this.socket.send(text);
        })
            .catch((error) => {
            // FIXME: also print the class name
            console.log("ORB.handleMethod(): the method '" + msg.method + "' threw an error: ", error);
        });
    }
    handleListInitialReferences(msg) {
        let result = new Array();
        for (let [id, obj] of this.initialReferences) {
            result.push(id);
        }
        let answer = {
            "corba": "1.0",
            "result": result,
            "reqid": msg.reqid
        };
        let text = JSON.stringify(answer);
        if (this.debug > 0) {
            console.log("ORB.handleListInitialReferences(): sending call reply " + text);
        }
        this.socket.send(text);
    }
    handleResolveInitialReferences(msg) {
        let object = this.initialReferences.get(msg.resolve);
        if (object === undefined) {
            console.log("ORB.handleResolveInitialReferences(): failed to resolve '" + msg.resolve + "'");
            object = null;
        }
        else {
            this.aclAdd(object);
        }
        let answer = {
            "corba": "1.0",
            "result": this.serialize(object),
            "reqid": msg.reqid
        };
        let text = JSON.stringify(answer);
        if (this.debug > 0) {
            console.log("ORB.handleResolveInitialReferences(): sending call reply " + text);
        }
        this.socket.send(text);
    }
    listen(host, port) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error("pure virtual function ORB.listen() being called in browser ORB");
        });
    }
    accept() {
        throw Error("pure virtual function ORB.accept() being called in browser ORB");
    }
}
exports.ORB = ORB;
ORB.valueTypeByName = new Map();
ORB.valueTypeByPrototype = new Map();
class CORBAObject {
    constructor(orb, id) {
        this.orb = orb;
        this.id = id;
    }
}
exports.CORBAObject = CORBAObject;
class Skeleton extends CORBAObject {
    constructor(orb) {
        super(orb, 0);
        this.id = orb.registerServant(this);
        this.acl = new Set();
    }
    release() {
    }
}
exports.Skeleton = Skeleton;
class Stub extends CORBAObject {
    constructor(orb, remoteID) {
        super(orb, remoteID);
    }
    release() {
        this.orb.releaseStub(this);
    }
}
exports.Stub = Stub;
//# sourceMappingURL=orb.js.map